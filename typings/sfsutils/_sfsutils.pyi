"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, List, Optional, Union

"""Parser for KSP savefiles"""
BACKEND = ...
def parse_savefile(sfs: str, sfs_is_path: bool = ...) -> Dict[str, Any]:
    """Parses an SFS file

    Params:
        sfs: str; the path to the SFS file to read or a string containing data read from an sfs.
        sfs_is_path (optional, default True): bool; whether the 'sfs' param is a path or raw data.
    Raises:
        No specific exceptions.
    Returns:
        Dictionary containing the data in the SFS.
    Extra information:
        All values are strings as SFS files do not reveal data to be any type.
        The SFS format is particularly bad and this leads to the returned dictionary
        containing data that is unusually structured. If the SFS contains multiple keys of any
        kind with the same name (this can be a 'node' header or values in a node), then the data
        contained within these keys will formatted as the common name of the keys as a key
        in a dict, and the values as a list. This data will always be in the exact order
        that they were in in the SFS (dictionaries are ordered in python3.6+). Example:

        --SFS format--
        NODE
        {
            x = 1
            x = 2
            y = 3
        }
        NODE
        {
            value = 1
        }
        OTHER
        {
            z = 4
        }

        --Python structure--
        {
            "NODE": [
                {"x": ["1","2"], "y": "3"},
                {"value": "1"}
            ],
            "OTHER": {
                "z": "4"
            }
        }
    """
    ...

def set_value(dict_nested: Dict, address_list: List[str], value: Union[str, Dict]) -> None:
    """Sets a value in a nested dict
    WARNING - mutates the dictionary passed as an argument"""
    ...

def writeout_savefile(parsed_data: Dict, destination_file: Optional[str] = ...) -> Optional[str]:
    """Writes out the parsed data back into the SFS format

    Params:
        parsed_data: dict; the parsed dictionary generated by parse_savefile.
        destination_file (optional): str; the destination file to write the SFS to.
    Raises:
        No specific exceptions.
    Returns:
        str containing the generated SFS if a destination file is not specified.
        None if a destination file is specified.
    Extra information:
        This function will generate a byte perfect copy of the original SFS parsed assuming
        the data is not modified. All abnormalities of the SFS format are addressed and
        represented correctly.
    """
    ...

def serialise_data(obj: Union[List, Dict], out_data: List[str], indents: int) -> None:
    """Recursively serialises data"""
    ...

def write_new_node(out_data: List[str], indent_str: str, indents: int, sect_name: str, value: Union[List, Dict]) -> None:
    """Write a new node to the SFS"""
    ...

